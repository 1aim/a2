//! # A2
//!
//! A2 is an asynchronous client to Apple push notification service. It
//! provides a type-safe way to generate correct requests, mapping responses into
//! corresponding types. The client supports both, certificate and token based
//! authentication.
//!
//! To create a connection it is required to have either a PKCS12 database file
//! including a valid certificate and private key with a password for unlocking
//! it, or a private key in PKCS8 PEM format with the corresponding team and key
//! ids. All of these should be available from Xcode or your Apple developer
//! account.
//!
//! The library is meant to be high performace and typesafe, used together with
//! the [Tokio framework](https://tokio.rs) in an asynchronous event loop.
//!
//! ## Payload
//!
//! Building the notification payload should be done with the corresponding builders:
//!
//! * [PlainNotificationBuilder](request/notification/struct.PlainNotificationBuilder.html) for text only messages.
//! * [SilentNotificationBuilder](request/notification/struct.SilentNotificationBuilder.html) for silent notifications with custom data.
//! * [LocalizedNotificationBuilder](request/notification/struct.LocalizedNotificationBuilder.html) for localized rich notifications.
//!
//! The payload generated by the builder [can hold a custom data
//! section](/a2/request/payload/struct.Payload.html#method.add_custom_data),
//! defined by a selected root key. Any data using `#[derive(Serialize)]` from
//! [Serde](https://serde.rs/) works, allowing usage of type-safe structs or
//! dynamic hashmaps to generate the custom data.
//!
//! ## Client
//!
//! The [asynchronous client](client/struct.Client.html), works either with
//! [certificate](client/struct.Client.html#method.certificate) or
//! [token](client/struct.Client.html#method.token) authentication.
//!
//! ## Example sending a plain notification using token authentication:
//!
//! ```no_run
//! extern crate tokio;
//! extern crate a2;
//! extern crate futures;
//!
//! use a2::request::notification::{PlainNotificationBuilder, NotificationBuilder};
//! use a2::client::{Client, Endpoint};
//! use std::fs::File;
//! use futures::future::lazy;
//! use futures::Future;
//!
//! fn main() {
//!     let mut builder = PlainNotificationBuilder::new("Hi there");
//!     builder.set_badge(420);
//!     builder.set_category("cat1");
//!     builder.set_sound("ping.flac");
//!
//!     let payload = builder.build("device-token-from-the-user", Default::default());
//!     let mut file = File::open("/path/to/private_key.p8").unwrap();
//!
//!     let client = Client::token(
//!         &mut file,
//!         "KEY_ID",
//!         "TEAM_ID",
//!         Endpoint::Production).unwrap();
//!
//!     tokio::run(lazy(move || {
//!         client
//!             .send(payload)
//!             .map(|response| {
//!                 println!("Sent: {:?}", response);
//!             })
//!             .map_err(|error| {
//!                 println!("Error: {:?}", error);
//!            })
//!     }));
//! }
//! ```
//!
//! ## Example sending a silent notification with custom data using certificate authentication:
//!
//! ```no_run
//! #[macro_use] extern crate serde_derive;
//! extern crate serde;
//! extern crate tokio;
//! extern crate a2;
//! extern crate futures;
//!
//! use a2::request::notification::{SilentNotificationBuilder, NotificationBuilder};
//! use a2::client::{Client, Endpoint};
//! use std::fs::File;
//! use futures::future::lazy;
//! use futures::Future;
//!
//! #[derive(Serialize, Debug)]
//! struct CorporateData {
//!     tracking_code: &'static str,
//!     is_paying_user: bool,
//! }
//!
//! fn main() {
//!     let tracking_data = CorporateData {
//!         tracking_code: "999-212-UF-NSA",
//!         is_paying_user: false,
//!     };
//!
//!     let mut payload = SilentNotificationBuilder::new()
//!         .build("device-token-from-the-user", Default::default());
//!     payload.add_custom_data("apns_gmbh", &tracking_data).unwrap();
//!
//!     let mut file = File::open("/path/to/cert_db.p12").unwrap();
//!
//!     let client = Client::certificate(
//!         &mut file,
//!         "Correct Horse Battery Stable",
//!         Endpoint::Production).unwrap();
//!
//!     tokio::run(lazy(move || {
//!         client
//!             .send(payload)
//!             .map(|response| {
//!                 println!("Sent: {:?}", response);
//!             })
//!             .map_err(|error| {
//!                 println!("Error: {:?}", error);
//!            })
//!     }));
//! }
//! ```

#[macro_use]
extern crate serde_derive;

#[allow(unused_imports)]
#[macro_use]
extern crate serde_json;

#[allow(unused_imports)]
#[macro_use]
extern crate indoc;

#[macro_use]
extern crate log;

extern crate base64;
extern crate chrono;
extern crate crossbeam;
extern crate erased_serde;
extern crate futures;
extern crate hyper;
extern crate openssl;
extern crate rustls;
extern crate serde;
extern crate http;
extern crate time;
extern crate tokio;
extern crate tokio_io;
extern crate tokio_rustls;
extern crate tokio_service;
extern crate tokio_timer;
extern crate webpki;
extern crate webpki_roots;

pub mod request;
pub mod error;
pub mod response;
pub mod client;
mod signer;
mod alpn;
